<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Sentence, Word, Morpheme, Relationship, POS} from './koalanlp/data';

let java = {};

/**
 * Utility methods
 * @type {{POS: POS, TYPES}}
 * @property {POS} POS 품사분석을 위한 도구.
 * @property {Object} TYPES 분석기 API 목록.
 */
export let util = {
    POS: POS,
    TYPES: require('./koalanlp/const').TYPES
};

/**
 * 분석결과 Callback
 * @callback parseCallback
 * @param {{error: *, result: Sentence[]}} result
 * @return *
 */

/**
 * 품사분석기 Wrapper 클래스
 */
export class Tagger{
    /**
     * 품사분석기를 생성합니다.
     * @param {string} taggerType API 유형
     */
    constructor(taggerType){
        let Base = java.import(`kr.bydelta.koala.${taggerType}.Tagger`);
        this.tagger = new Base();
    }

    /**
     * 문단단위 품사표기
     * @param {string} paragraph 품사표기할 문단.
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 품사표기 결과가 반환됨.
     */
    tag(paragraph, callback){
        if(callback){
            this.tagger.tag(paragraph, function(err, result){
                if(err) callback({error: err});
                else callback({error: false, result: converter(result)});
            });
        }else{
            return converter(this.tagger.tagSync(paragraph))
        }
    }

    /**
     * 문장단위 품사표기
     * @param {string} sentence 품사표기할 문장.
     * @param {parseCallback=} callback 콜백함수 (Object => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 품사표기 결과가 반환됨.
     */
    tagSentence(sentence, callback){
        if(callback){
            this.tagger.tagSentence(sentence, function(err, result){
                if(err) callback({error: err});
                else callback({error: false, result: [convertSentence(result)]});
            });
        }else{
            return convertSentence(this.tagger.tagSentenceSync(sentence))
        }
    }
}

/**
 * 의존구문분석기 Wrapper 클래스
 */
export class Parser{
    /**
     * 의존구문분석기를 생성합니다.
     * @param {string} parserType 의존구문분석기 API 패키지.
     * @param {string|undefined} [taggerType=undefined] 품사분석기 API 패키지. 미지정시, 의존구문분석기 패키지 이용.
     */
    constructor(parserType, taggerType){
        if(taggerType) {
            let TagBase = java.import(`kr.bydelta.koala.${taggerType}.Tagger`);
            this.tagger = new TagBase();
        }

        let ParseBase = java.import(`kr.bydelta.koala.${parserType}.Parser`);
        this.parser = new ParseBase();
    }

    /**
     * 문단단위 분석
     * @param {string} paragraph 분석할 문단.
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    parse(paragraph, callback){
        if(this.tagger) {
            if (callback) {
                let parser = this.parser;
                this.tagger.tag(paragraph, function (err, result) {
                    if (err) callback({error: err});
                    else parser.parse(result, function (err2, parsed) {
                        if (err2) callback({error: err2});
                        else callback({error: false, result: converter(parsed)});
                    });
                });
            } else {
                let tagged = this.tagger.tagSync(paragraph);
                let parsed = this.parser.parseSync(tagged);
                return converter(parsed);
            }
        }else{
            if (callback) {
                this.parser.parse(paragraph, function (err, parsed) {
                    if (err) callback({error: err});
                    else callback({error: false, result: converter(parsed)});
                });
            } else {
                let parsed = this.parser.parseSync(paragraph);
                return converter(parsed);
            }
        }
    }

    /**
     * 문장단위 분석
     * @param {string} sentence 분석할 문장.
     * @param {parseCallback=} callback 콜백함수 (Object => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    parseSentence(sentence, callback){
        if(this.tagger) {
            if (callback) {
                let parser = this.parser;
                this.tagger.tagSentence(sentence, function (err, result) {
                    if (err) callback({error: err});
                    else parser.parseSentence(result, function (err2, parsed) {
                        if (err2) callback({error: err2});
                        else callback({error: false, result: [convertSentence(parsed)]});
                    });
                });
            } else {
                let tagged = this.tagger.tagSentenceSync(sentence);
                let parsed = this.parser.parseSentenceSync(tagged);
                return convertSentence(parsed);
            }
        }else{
            if (callback) {
                this.parser.parseSentence(sentence, function (err, parsed) {
                    if (err) callback({error: err});
                    else callback({error: false, result: [convertSentence(parsed)]});
                });
            } else {
                let parsed = this.parser.parseSentenceSync(sentence);
                return convertSentence(parsed);
            }
        }
    }
}

/**
 * 초기화 Callback
 * @callback initCallback
 * @return *
 */

/**
 * 의존패키지 초기화 및 사전적재 함수
 * @param {{version: string|undefined, packages: string[]|undefined,
 * tempJsonName: string|undefined, debug: boolean|undefined, javaOptions: string[]|undefined}} obj 설정 Object
 * @param {initCallback} callback 콜백 함수 (void => void)
 */
export let initialize = function(obj, callback){
    obj.version = obj.version || "1.9.0";
    obj.packages = obj.packages || [util.TYPES.EUNJEON, util.TYPES.KKMA];
    obj.tempJsonName = obj.tempJsonName || "koalanlp.json";
    obj.debug = obj.debug === true;
    obj.javaOptions = obj.javaOptions || ["-Xmx4g"];

    require('./koalanlp/javainit').initializer(obj, function(jvm){
        java = jvm;
        callback();
    });
};

let convertWord = function(result, widx){
    let len = result.lengthSync();
    let buffer = [];
    let surface = result.surfaceSync();

    for(let i = 0; i &lt; len; i ++){
        let morphs = result.applySync(i);
        let morpheme =
            new Morpheme(
                morphs.surfaceSync(),
                morphs.tagSync().toStringSync(),
                morphs.rawTagSync(),
                i
            );
        buffer.push(morpheme);
    }

    let word = new Word(surface, buffer, widx);
    let dependents = result.depsSync().toSeqSync();
    len = dependents.sizeSync();

    for(let i = 0; i &lt; len; i ++){
        let rel = dependents.applySync(i);
        let relationship =
            new Relationship(
                rel.headSync(),
                rel.relationSync().toStringSync(),
                rel.rawRelSync(),
                rel.targetSync()
            );
        word.dependents.push(relationship);
    }

    return word;
};

let convertSentence = function(result){
    let len = result.lengthSync();
    let words = [];

    for(let i = 0; i &lt; len; i ++){
        let word = result.applySync(i);
        words.push(convertWord(word, i));
    }

    let sentence = new Sentence(words);
    let dependents = result.rootSync().depsSync().toSeqSync();
    len = dependents.sizeSync();

    for(let i = 0; i &lt; len; i ++){
        let rel = dependents.applySync(i);
        let relationship =
            new Relationship(
                rel.headSync(),
                rel.relationSync().toStringSync(),
                rel.rawRelSync(),
                rel.targetSync()
            );
        sentence.root.dependents.push(relationship);
    }

    return sentence;
};

let converter = function(result){
    let len = result.sizeSync();
    let buffer = [];

    for(let i = 0; i &lt; len; i ++){
        let sentence = result.applySync(i);
        buffer.push(convertSentence(sentence));
    }
    return buffer;
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Morpheme.html">Morpheme</a></li><li><a href="Parser.html">Parser</a></li><li><a href="POS.html">POS</a></li><li><a href="Relationship.html">Relationship</a></li><li><a href="Sentence.html">Sentence</a></li><li><a href="Tagger.html">Tagger</a></li><li><a href="Word.html">Word</a></li></ul><h3>Global</h3><ul><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#util">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jan 05 2018 22:22:31 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
