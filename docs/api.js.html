<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Sentence, Word, Morpheme, Relationship} from './koalanlp/data';

/**
 * @private
 * @type {{import:*, newInstanceSync:*, callStaticMethodSync:*}}
 */
let java = {};

/**
 * Assert method
 * @param cond Condition to be checked.
 * @param msg Message to be thrown if condition check is failed.
 */
let assert = function(cond, msg){
    if(!cond)
        throw new Error(msg ? msg : "Assertion failed!");
};

/**
 * 분석기 API 목록.
 */
export let API = require('./koalanlp/const').API;

/**
 * 품사분석을 위한 도구.
 * @type {POS}
 */
export let POS = require('./POS');

/**
 * 분석결과 Callback
 * @callback parseCallback
 * @param {{error: *, result: Sentence[]}} result
 * @return *
 */

/**
 * 품사분석기 Wrapper 클래스
 */
export class Tagger{
    /**
     * 품사분석기를 생성합니다.
     * @param {string} taggerType API 유형
     */
    constructor(taggerType){
        let Base = java.import(`kr.bydelta.koala.${taggerType}.Tagger`);
        this.tagger = new Base();
    }

    /**
     * 문단단위 품사표기
     * @param {string} paragraph 품사표기할 문단.
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 품사표기 결과가 반환됨.
     */
    tag(paragraph, callback){
        if (callback) {
            this.tagger.tag(paragraph, function (err, result) {
                if (err) callback({error: err, result: []});
                else callback({error: false, result: converter(result)});
            });
        } else {
            return converter(this.tagger.tagSync(paragraph))
        }
    }

    /**
     * 문장단위 품사표기
     * @param {string} sentence 품사표기할 문장.
     * @param {parseCallback=} callback 콜백함수 (Object => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 품사표기 결과가 반환됨.
     */
    tagSentence(sentence, callback){
        if(callback){
            this.tagger.tagSentence(sentence, function(err, result){
                if(err) callback({error: err, result: []});
                else callback({error: false, result: [convertSentence(result)]});
            });
        }else{
            return convertSentence(this.tagger.tagSentenceSync(sentence))
        }
    }
}

/**
 * 의존구문분석기 Wrapper 클래스
 */
export class Parser{
    /**
     * 의존구문분석기를 생성합니다.
     * @param {string} parserType 의존구문분석기 API 패키지.
     * @param {string|undefined} [taggerType=undefined] 품사분석기 API 패키지. 미지정시, 의존구문분석기 패키지 이용.
     */
    constructor(parserType, taggerType){
        assert(parserType == util.TYPES.KKMA || parserType == util.TYPES.HANNANUM,
            "꼬꼬마/한나눔을 제외한 분석기는 의존구문분석을 지원하지 않습니다.");

        if(taggerType) {
            let TagBase = java.import(`kr.bydelta.koala.${taggerType}.Tagger`);
            this.tagger = new TagBase();
        }

        let ParseBase = java.import(`kr.bydelta.koala.${parserType}.Parser`);
        this.parser = new ParseBase();
    }

    /**
     * 문단단위 분석
     * @param {string|Sentence[]} paragraph 분석할 문단.
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    parse(paragraph, callback){
        let isSentences = Array.isArray(paragraph) &amp;&amp; paragraph[0] instanceof Sentence;

        if(this.tagger &amp;&amp; !isSentences) {
            if (callback) {
                let parser = this.parser;
                this.tagger.tag(paragraph, function (err, result) {
                    if (err) callback({error: err, result: []});
                    else parser.parse(result, function (err2, parsed) {
                        if (err2) callback({error: err2, result: []});
                        else callback({error: false, result: converter(parsed)});
                    });
                });
            } else {
                let tagged = this.tagger.tagSync(paragraph);
                let parsed = this.parser.parseSync(tagged);
                return converter(parsed);
            }
        }else{
            let target = paragraph;
            if (isSentences){
                target = [];
                for(let i = 0; i &lt; paragraph.length; i ++){
                    target.push(paragraph[i].reference);
                }
            }

            if (callback) {
                this.parser.parse(target, function (err, parsed) {
                    if (err) callback({error: err, result: []});
                    else callback({error: false, result: converter(parsed)});
                });
            } else {
                let parsed = this.parser.parseSync(target);
                return converter(parsed);
            }
        }
    }

    /**
     * 문장단위 분석
     * @param {string|Sentence} sentence 분석할 문장.
     * @param {parseCallback=} callback 콜백함수 (Object => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    parseSentence(sentence, callback){
        let isSentence = sentence instanceof Sentence;

        if(this.tagger &amp;&amp; !isSentence) {
            if (callback) {
                let parser = this.parser;
                this.tagger.tagSentence(sentence, function (err, result) {
                    if (err) callback({error: err, result: []});
                    else parser.parse(result, function (err2, parsed) {
                        if (err2) callback({error: err2, result: []});
                        else callback({error: false, result: [convertSentence(parsed)]});
                    });
                });
            } else {
                let tagged = this.tagger.tagSentenceSync(sentence);
                let parsed = this.parser.parseSync(tagged);
                return convertSentence(parsed);
            }
        }else{
            let target = isSentence? sentence.reference : sentence;
            if (callback) {
                this.parser.parse(target, function (err, parsed) {
                    if (err) callback({error: err, result: []});
                    else callback({error: false, result: [convertSentence(parsed)]});
                });
            } else {
                let parsed = this.parser.parseSync(target);
                return convertSentence(parsed);
            }
        }
    }
}

/**
 * 문장분리기 클래스
 */
export class SentenceSplitter{
    /**
     * 문장분리기를 생성합니다.
     * @param {string} splitterType 문장분리기 API 패키지.
     */
    constructor(splitterType){
        assert(splitterType === util.TYPES.TWITTER || splitterType === util.TYPES.HANNANUM,
            "오픈한글(트위터)/한나눔을 제외한 분석기는 문장분리를 지원하지 않습니다.");

        let SegBase = java.import(`kr.bydelta.koala.${splitterType}.SentenceSplitter`);
        this.splitter = new SegBase();
    }

    /**
     * 문단을 문장으로 분리합니다.
     * @param {string} paragraph 분석할 문단.
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    sentences(paragraph, callback){
        if (callback) {
            this.splitter.sentences(paragraph, function (err, parsed) {
                if (err) callback({error: err, result: []});
                else callback({error: false, result: convertSentenceStr(parsed)});
            });
        } else {
            let parsed = this.splitter.sentencesSync(paragraph);
            return convertSentenceStr(parsed);
        }
    }

    /**
     * KoalaNLP가 구현한 문장분리기를 사용하여, 문단을 문장으로 분리합니다.
     * @param {Sentence} paragraph 분석할 문단. (품사표기가 되어있어야 합니다)
     * @param {parseCallback=} callback 콜백함수 (Object[] => void). 지정된 경우, 결과를 전달받음.
     * @return {Sentence[]|undefined} callback이 없는 경우, 분석 결과가 반환됨.
     */
    static sentencesByKoala(paragraph, callback){
        assert(paragraph instanceof Sentence);
        if (callback) {
            java.callStaticMethod("kr.bydelta.koala.util.SentenceSplitter", "apply",
                paragraph.reference, function (err, parsed) {
                if (err) callback({error: err, result: []});
                else callback({error: false, result: converter(parsed)});
            });
        } else {
            let parsed = java.callStaticMethodSync("kr.bydelta.koala.util.SentenceSplitter", "apply",
                paragraph.reference);
            return converter(parsed);
        }
    }
}

/**
 * 품사 필터링 함수
 * @callback POSFilter
 * @param {string} POS 품사
 * @return {boolean} 품사가 포함 되는지의 여부.
 */

/**
 * 사전 import 콜백 함수.
 * @callback DictImportCallback
 * @return *
 */

/**
 * 사용자 정의 사전 클래스
 */
export class Dictionary{
    /**
     * 사용자 정의 사전을 연결합니다.
     * @param {string} dicType 사용자 정의 사전을 연결할 API 패키지.
     */
    constructor(dicType){
        assert(dicType !== util.TYPES.RHINO,
            "라이노 분석기는 사용자 정의 사전을 지원하지 않습니다.");
        this.dict = java.callStaticMethodSync(`kr.bydelta.koala.${dicType}.JavaDictionary`, 'get')
    }

    /**
     * 사용자 사전에, 표면형과 그 품사를 추가.
     *
     * @param {string|string[]} morph 표면형.
     * @param {string|string[]} tag   세종 품사.
     */
    addUserDictionary(morph, tag){
        let isMArray = Array.isArray(morph);
        let isTArray = Array.isArray(tag);

        assert(isMArray == isTArray,
            "형태소와 품사는 둘 다 같은 길이의 배열이거나 둘 다 string이어야 합니다.");

        if(isMArray){
            assert(morph.length == tag.length,
                "형태소와 품사는 둘 다 같은 길이의 배열이어야 합니다.");
            let tuples = [];
            for(let i = 0; i &lt; morph.length; i ++){
                tuples.push(morphToTuple(morph[i], tag[i]));
            }
            this.dict.addUserDictionarySync(morph, tuples);
        }else {
            let posTag = java.callStaticMethodSync("kr.bydelta.koala.POS", "withName", tag);
            this.dict.addUserDictionarySync(morph, posTag);
        }
    }

    /**
     * 사전에 등재되어 있는지 확인합니다.
     *
     * @param {string} word   확인할 형태소
     * @param {...string} posTag 세종품사들(기본값: NNP 고유명사, NNG 일반명사)
     */
    contains(word, ...posTag){
        let tags = posTag || ["NNP", "NNG"];
        let posTags = [];
        for(let i = 0; i &lt; tags.length; i ++){
            posTags.push(java.callStaticMethodSync("kr.bydelta.koala.POS", "withName", tags[i]));
        }
        let posSet = java.callStaticMethodSync("scala.Predef", "genericArrayOps", posTags).toSetSync();

        return this.dict.containsSync(word, posSet);
    }

    /**
     * 사전에 등재되어 있는지 확인하고, 사전에 없는단어만 반환합니다.
     *
     * @param {boolean} onlySystemDic 시스템 사전에서만 검색할지 결정합니다.
     * @param {...{morph:string, pos:string}} word 확인할 (형태소, 품사)들.
     * @return 사전에 없는 단어들.
     */
    getNotExists(onlySystemDic, ...word){
        let wordEntries = [];
        for(let i = 0; i &lt; word.length; i ++){
            wordEntries.push(morphToTuple(word[i]));
        }
        let wordSeq = java.callStaticMethodSync("scala.Predef", "genericArrayOps", wordEntries).toSeqSync();

        let notExists = this.dict.getNotExistsSync(onlySystemDic, wordSeq);
        let returnValue = [];
        for(let i = 0; i &lt; notExists.sizeSync(); i ++){
            let entry = notExists.applySync(i);
            returnValue.push({morph: entry._1, tag: entry._2.toStringSync()});
        }

        return returnValue;
    }

    /**
     * 다른 사전을 참조하여, 선택된 사전에 없는 단어를 사용자사전으로 추가합니다.
     *
     * @param {Dictionary} other 참조할 사전
     * @param {POSFilter} filterFn 추가할 품사를 지정하는 함수.
     * @param {boolean} fastAppend 선택된 사전에 존재하는지를 검사하지 않고 빠르게 추가하고자 할 때. (기본값 false)
     * @param {DictImportCallback} callback 사전 import가 종료된 다음 호출될 Callback 함수
     */
    importFrom(other, filterFn, fastAppend, callback){
        assert(typeof callback !== "undefined", "Callback should be defined.");
        fastAppend = fastAppend || false;

        let tags = POS.TAGS.filter(filterFn);
        let tagSet = java.callStaticMethodSync("scala.Predef", "genericArrayOps", tags).toSetSync();

        this.dict.importFrom(other.dict, filterFn, fastAppend, callback);
    }

    /**
     * 원본 사전에 등재된 항목 중에서, 지정된 형태소의 항목만을 가져옵니다. (복합 품사 결합 형태는 제외)
     *
     * @param {POSFilter} filterFn 가져올 품사인지 판단하는 함수.
     * @return {{morph: string, tag: string}} (형태소, 품사) generator.
     */
    baseEntriesOf(filterFn){
        filterFn = filterFn || POS.isNoun;

        let tags = POS.TAGS.filter(filterFn);
        let tagSet = java.callStaticMethodSync("scala.Predef", "genericArrayOps", tags).toSetSync();

        let entries = this.dict.baseEntriesOfSync(tagSet);
        let generator = function*(){
            while (entries.hasNextSync()){
                let entry = entries.nextSync();
                yield {morph: entry._1, tag: entry._2.toStringSync()};
            }
        };

        return generator();
    }
}

/**
 * 초기화 Callback
 * @callback initCallback
 * @return *
 */

/**
 * 의존패키지 초기화 및 사전적재 함수
 * @param {{version: string|undefined, packages: string[]|undefined,
 * tempJsonName: string|undefined, debug: boolean|undefined, javaOptions: string[]|undefined,
 * useIvy2: boolean}} obj 설정 Object
 * @param {initCallback} callback 콜백 함수 (void => void)
 */
export let initialize = function(obj, callback){
    if (typeof obj === "function"){
        callback = obj;
        obj = {};
    }else if(typeof obj === "undefined"){
        obj = {};
    }

    obj.version = obj.version || "1.9.0";
    obj.packages = obj.packages || [util.TYPES.EUNJEON, util.TYPES.KKMA];
    obj.tempJsonName = obj.tempJsonName || "koalanlp.json";
    obj.debug = obj.debug === true;
    obj.javaOptions = obj.javaOptions || ["-Xmx4g"];
    obj.useIvy2 = obj.useIvy2 || false;

    require('./koalanlp/javainit').initializer(obj, function(jvm){
        java = jvm;
        console.log("[KoalaNLP] Jar file loading finished.");
        if(callback)
            callback();
    });
};

let convertWord = function(result, widx){
    let len = result.lengthSync();
    let buffer = [];
    let surface = result.surfaceSync();

    for(let i = 0; i &lt; len; i ++){
        let morphs = result.applySync(i);
        let morpheme =
            new Morpheme(
                morphs.surfaceSync(),
                morphs.tagSync().toStringSync(),
                morphs.rawTagSync(),
                i
            );
        buffer.push(morpheme);
    }

    let word = new Word(surface, buffer, widx);
    let dependents = result.depsSync().toSeqSync();
    len = dependents.sizeSync();

    for(let i = 0; i &lt; len; i ++){
        let rel = dependents.applySync(i);
        let relationship =
            new Relationship(
                rel.headSync(),
                rel.relationSync().toStringSync(),
                rel.rawRelSync(),
                rel.targetSync()
            );
        word.dependents.push(relationship);
    }

    return word;
};

let convertSentence = function(result){
    let len = result.lengthSync();
    let words = [];

    for(let i = 0; i &lt; len; i ++){
        let word = result.applySync(i);
        words.push(convertWord(word, i));
    }

    let sentence = new Sentence(words, result);
    let dependents = result.rootSync().depsSync().toSeqSync();
    len = dependents.sizeSync();

    for(let i = 0; i &lt; len; i ++){
        let rel = dependents.applySync(i);
        let relationship =
            new Relationship(
                rel.headSync(),
                rel.relationSync().toStringSync(),
                rel.rawRelSync(),
                rel.targetSync()
            );
        sentence.root.dependents.push(relationship);
    }

    return sentence;
};

let converter = function(result){
    let len = result.sizeSync();
    let buffer = [];

    for(let i = 0; i &lt; len; i ++){
        let sentence = result.applySync(i);
        buffer.push(convertSentence(sentence));
    }
    return buffer;
};

let convertSentenceStr = function(result){
    let len = result.sizeSync();
    let buffer = [];

    for(let i = 0; i &lt; len; i ++){
        let sentence = result.applySync(i);
        buffer.push(sentence);
    }
    return buffer;
};

let morphToTuple = function(obj, tag){
    let morph = tag? obj : obj.morph;
    let pos = tag? tag : obj.tag;

    let posEntry = java.callStaticMethodSync("kr.bydelta.koala.POS", "withName", pos);
    return java.newInstanceSync("scala.Tuple2", morph, posEntry);
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Morpheme.html">Morpheme</a></li><li><a href="Parser.html">Parser</a></li><li><a href="Relationship.html">Relationship</a></li><li><a href="Sentence.html">Sentence</a></li><li><a href="SentenceSplitter.html">SentenceSplitter</a></li><li><a href="Tagger.html">Tagger</a></li><li><a href="Word.html">Word</a></li></ul><h3>Global</h3><ul><li><a href="global.html#API">API</a></li><li><a href="global.html#assert">assert</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#isAffix">isAffix</a></li><li><a href="global.html#isEnding">isEnding</a></li><li><a href="global.html#isModifier">isModifier</a></li><li><a href="global.html#isNoun">isNoun</a></li><li><a href="global.html#isPostposition">isPostposition</a></li><li><a href="global.html#isPredicate">isPredicate</a></li><li><a href="global.html#isSuffix">isSuffix</a></li><li><a href="global.html#isSymbol">isSymbol</a></li><li><a href="global.html#isUnknown">isUnknown</a></li><li><a href="global.html#POS">POS</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jan 26 2018 18:08:10 GMT+0900 (KST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
