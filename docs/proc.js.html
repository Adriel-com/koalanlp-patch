<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>proc.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://koalanlp.github.io/koalanlp/usage" target="_blank" class="menu-item" id="website_link" >사용법 안내</a></h2><h2><a href="https://koalanlp.github.io/koalanlp" target="_blank" class="menu-item" id="website_link" >참고: Java/Kotlin API</a></h2><h2><a href="https://koalanlp.github.io/scala-support" target="_blank" class="menu-item" id="website_link" >참고: Scala API</a></h2><h2><a href="https://koalanlp.github.io/python-support" target="_blank" class="menu-item" id="website_link" >참고: Python3 API</a></h2><h3>Modules</h3><ul><li><a href="module-koalanlp_API.html">koalanlp/API</a></li><li><a href="module-koalanlp_ExtUtil.html">koalanlp/ExtUtil</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.alphaToHangul">alphaToHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.hangulToAlpha">hangulToAlpha</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isAlphaPronounced">isAlphaPronounced</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isHanja">isHanja</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isCJKHanja">isCJKHanja</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.hanjaToHangul">hanjaToHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isCompleteHangul">isCompleteHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isIncompleteHangul">isIncompleteHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isHangul">isHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isHangulEnding">isHangulEnding</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isChosungJamo">isChosungJamo</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isJungsungJamo">isJungsungJamo</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isJongsungJamo">isJongsungJamo</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.isJongsungEnding">isJongsungEnding</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.getChosung">getChosung</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.getJungsung">getJungsung</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.getJongsung">getJongsung</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.dissembleHangul">dissembleHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.assembleHangulTriple">assembleHangulTriple</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.assembleHangul">assembleHangul</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_ExtUtil.html#.correctVerbApply">correctVerbApply</a></li></ul></li><li><a href="module-koalanlp_Util.html">koalanlp/Util</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_Util.html#.initialize">initialize</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_Util.html#.contains">contains</a></li></ul></li><li><a href="module-koalanlp_data.html">koalanlp/data</a></li><li><a href="module-koalanlp_proc.html">koalanlp/proc</a></li><li><a href="module-koalanlp_types.html">koalanlp/types</a></li></ul><h3>Classes</h3><ul><li><a href="module-koalanlp_data.Entity.html">Entity</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#getSurface">getSurface</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#getLabel">getLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#getFineLabel">getFineLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#getCorefGroup">getCorefGroup</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#getOriginalLabel">getOriginalLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#equals">equals</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Entity.html#toString">toString</a></li></ul></li><li><a href="module-koalanlp_data.CoreferenceGroup.html">CoreferenceGroup</a></li><li><a href="module-koalanlp_data.Tree.html">Tree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#getLabel">getLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#getTerminal">getTerminal</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#isRoot">isRoot</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#hasNonTerminals">hasNonTerminals</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#getTreeString">getTreeString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#getParent">getParent</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#getNonTerminals">getNonTerminals</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#toString">toString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Tree.html#equals">equals</a></li></ul></li><li><a href="module-koalanlp_data.SyntaxTree.html">SyntaxTree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.SyntaxTree.html#getOriginalLabel">getOriginalLabel</a></li></ul></li><li><a href="module-koalanlp_data.DAGEdge.html">DAGEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DAGEdge.html#getSrc">getSrc</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DAGEdge.html#getDest">getDest</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DAGEdge.html#getLabel">getLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DAGEdge.html#toString">toString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DAGEdge.html#equals">equals</a></li></ul></li><li><a href="module-koalanlp_data.DepEdge.html">DepEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#getGovernor">getGovernor</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#getDependent">getDependent</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#getDepType">getDepType</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#getType">getType</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#getOriginalLabel">getOriginalLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#equals">equals</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.DepEdge.html#toString">toString</a></li></ul></li><li><a href="module-koalanlp_data.RoleEdge.html">RoleEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.RoleEdge.html#getPredicate">getPredicate</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.RoleEdge.html#getArgument">getArgument</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.RoleEdge.html#getModifiers">getModifiers</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.RoleEdge.html#getOriginalLabel">getOriginalLabel</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.RoleEdge.html#toString">toString</a></li></ul></li><li><a href="module-koalanlp_data.Morpheme.html">Morpheme</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getSurface">getSurface</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getTag">getTag</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getOriginalTag">getOriginalTag</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getId">getId</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getWordSense">getWordSense</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getEntities">getEntities</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#getWord">getWord</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#isNoun">isNoun</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#isPredicate">isPredicate</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#isModifier">isModifier</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#isJosa">isJosa</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#hasTag">hasTag</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#hasTagOneOf">hasTagOneOf</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#hasOriginalTag">hasOriginalTag</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#equals">equals</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Morpheme.html#toString">toString</a></li></ul></li><li><a href="module-koalanlp_data.Word.html">Word</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getSurface">getSurface</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getId">getId</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getEntities">getEntities</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getPhrase">getPhrase</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getDependentEdges">getDependentEdges</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getGovernorEdge">getGovernorEdge</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getArgumentRoles">getArgumentRoles</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#getPredicateRoles">getPredicateRoles</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#singleLineString">singleLineString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#toString">toString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Word.html#equals">equals</a></li></ul></li><li><a href="module-koalanlp_data.Sentence.html">Sentence</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getSyntaxTree">getSyntaxTree</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getDependencies">getDependencies</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getRoles">getRoles</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getEntities">getEntities</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getCorefGroups">getCorefGroups</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getNouns">getNouns</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getVerbs">getVerbs</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#getModifiers">getModifiers</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#surfaceString">surfaceString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#singleLineString">singleLineString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#toString">toString</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_data.Sentence.html#.fromJava">fromJava</a></li></ul></li><li><a href="module-koalanlp_proc.SentenceSplitter.html">SentenceSplitter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.SentenceSplitter.html#sentences">sentences</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.SentenceSplitter.html#.sentences">sentences</a></li></ul></li><li><a href="module-koalanlp_proc.Tagger.html">Tagger</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Tagger.html#tag">tag</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Tagger.html#tagSentence">tagSentence</a></li></ul></li><li><a href="module-koalanlp_proc.Parser.html">Parser</a></li><li><a href="module-koalanlp_proc.EntityRecognizer.html">EntityRecognizer</a></li><li><a href="module-koalanlp_proc.RoleLabeler.html">RoleLabeler</a></li><li><a href="module-koalanlp_proc.Dictionary.html">Dictionary</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#addUserDictionary">addUserDictionary</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#importFrom">importFrom</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#getBaseEntries">getBaseEntries</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#getItems">getItems</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_proc.Dictionary.html#getNotExists">getNotExists</a></li></ul></li><li><a href="module-koalanlp_types.POS.html">POS</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#.values">values</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#.withName">withName</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isNoun">isNoun</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isPredicate">isPredicate</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isModifier">isModifier</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isPostPosition">isPostPosition</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isEnding">isEnding</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isAffix">isAffix</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isSuffix">isSuffix</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isSymbol">isSymbol</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#isUnknown">isUnknown</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.POS.html#startsWith">startsWith</a></li></ul></li><li><a href="module-koalanlp_types.PhraseTag.html">PhraseTag</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_types.PhraseTag.html#.values">values</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.PhraseTag.html#.withName">withName</a></li></ul></li><li><a href="module-koalanlp_types.DependencyTag.html">DependencyTag</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_types.DependencyTag.html#.values">values</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.DependencyTag.html#.withName">withName</a></li></ul></li><li><a href="module-koalanlp_types.RoleType.html">RoleType</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_types.RoleType.html#.values">values</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.RoleType.html#.withName">withName</a></li></ul></li><li><a href="module-koalanlp_types.CoarseEntityType.html">CoarseEntityType</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-koalanlp_types.CoarseEntityType.html#.values">values</a></li><li data-type='method' style='display: none;'><a href="module-koalanlp_types.CoarseEntityType.html#.withName">withName</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">proc.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * 여러 분석기를 모아놓은 module입니다.
 * @module koalanlp/proc
 * @example
 * import { SentenceSplitter, Tagger, Parser, RoleLabeler, EntityRecognizer, Dictionary } from 'koalanlp/proc';
 **/

import {JVM} from './jvm';
import * as API from './API';
import {POS} from './types';
import {Sentence} from './data';


/**
 * POSFilter 함수
 * @callback POSFilter
 * @param {!POS} tag 검사할 품사 태그
 * @return {boolean} 해당하면 true.
 */

/**
 * 형태소 사전 항목. {'surface':형태소, 'tag':품사}
 * @typedef {Object} DicEntry
 * @property {!string} surface 형태소 표면형
 * @property {!POS} tag 형태소 품사
 */

/**
 * Build a Function Proxy object
 * @param {Object} thisObj
 * @param {!string} method
 * @returns {Object}
 * @private
 */
function assignProxy(thisObj, method) {
    return new Proxy(thisObj, {
        apply: async function (target, thisArg, argArray) {
            return await target[method](...argArray);
        }
    })
}

/**
 * 문장분리기 Wrapper입니다.
 * @example
 * import { SentenceSplitter } from 'koalanlp/proc';
 * import { OKT } from 'koalanlp/API';
 *
 * let splitter = new SentenceSplitter(OKT);
 * splitter("문장을 분리해봅니다. 이렇게요.");
 */
export class SentenceSplitter extends Function {
    /**
     * Java API Object
     * @type {Object}
     * @private
     */
    _api = null;

    /**
     * 문장분리기를 생성합니다.
     *
     * @param {!API} api 문장분리기 API 패키지.
     */
    constructor(api) {
        super();
        this._api = API.query(api, this.constructor.name);

        return assignProxy(this, 'sentences');
    }

    /**
     * 문단을 문장으로 분리합니다.
     * @param {...!string} text 분석할 문단들 (가변인자)
     * @returns {string[]} 분리한 문장들.
     */
    async sentences(...text) {
        let result = [];
        for (let paragraph of text) {
            let promiseResult = await this._api.sentencesPromise(paragraph);
            result.push(...JVM.toJsArray(promiseResult));
        }
        return result;
    }

    /**
     * KoalaNLP가 구현한 문장분리기를 사용하여, 문단을 문장으로 분리합니다.
     * @param {Word[]} paragraph 분석할 문단. (품사표기가 되어있어야 합니다)
     * @returns {Sentence} 분리된 문장
     */
    static async sentences(paragraph) {
        let sent = [];
        for (let word of paragraph) {
            sent.push(word.getReference());
        }

        let promiseResult = await JVM.koalaClassOf('proc', 'SentenceSplitter').INSTANCE.sentencesPromise(sent);
        return JVM.toJsArray(promiseResult, Sentence.fromJava);
    }
}

/**
 * 형태소 분석기
 *
 * ## 참고
 *
 * **형태소** 는 의미를 가지는 요소로서는 더 이상 분석할 수 없는 가장 작은 말의 단위로 정의됩니다.
 *
 * **형태소 분석** 은 문장을 형태소의 단위로 나누는 작업을 의미합니다.
 *
 * 예) '문장을 형태소로 나눠봅시다'의 경우,
 *
 * * 문장/일반명사, -을/조사,
 * * 형태소/일반명사, -로/조사,
 * * 나누-(다)/동사, -어-/어미, 보-(다)/동사, -ㅂ시다/어미
 *
 * 로 대략 나눌 수 있습니다.
 *
 * 아래를 참고해보세요.
 *
 * * {@link module:koalanlp/data.Morpheme|Morpheme} 형태소를 저장하는 형태.
 * * {@link module:koalanlp/types.POS|POS} 형태소의 분류를 담은 Enum class
 *
 * @example
 * import { Tagger } from 'koalanlp/proc';
 * import { KMR } from 'koalanlp/API';
 *
 * let tagger = new Tagger(KMR);
 * tagger("문장을 분석해봅니다. 이렇게요.");
 */
export class Tagger extends Function {
    /**
     * Java API Object
     * @type {Object}
     * @private
     */
    _api = null;

    /**
     * 품사분석기를 초기화합니다.
     *
     * @param {!API} api 사용할 품사분석기의 유형.
     * @param {Object} [options={}]
     * @param {string} options.apiKey ETRI 분석기의 경우, ETRI에서 발급받은 API Key
     * @param {boolean} [options.useLightTagger=false] 코모란(KMR) 분석기의 경우, 경량 분석기를 사용할 것인지의 여부.
     */
    constructor(api, options={}) {
        super();
        if (api === API.ETRI) {
            let apiKey = options.apiKey;
            this._api = API.query(api, this.constructor.name)(apiKey)
        } else if (api === API.KMR) {
            let useLightTagger = options.useLightTagger || false;
            this._api = API.query(api, this.constructor.name)(useLightTagger)
        } else {
            this._api = API.query(api, this.constructor.name)()
        }

        return assignProxy(this, 'tag');
    }

    /**
     * 문단(들)을 품사분석합니다.
     * @param {...(string|string[])} text 분석할 문단들. 텍스트와 string 리스트 혼용 가능. (가변인자)
     * @returns {Sentence[]} 분석된 결과 (Flattened list)
     */
    async tag(...text) {
        let result = [];
        for (let paragraph of text) {
            let promiseResult;
            if(Array.isArray(paragraph)) {
                promiseResult = await this.tag(...paragraph);
                result.push(...promiseResult);
            }else {
                promiseResult = await this._api.tagPromise(paragraph);
                result.push(...JVM.toJsArray(promiseResult, Sentence.fromJava));
            }
        }
        return result;
    }

    /**
     * 문장을 품사분석합니다. 각 인자 하나를 하나의 문장으로 간주합니다.
     *
     * @param {...!string} sentence 분석할 문장(들). (가변인자)
     * @returns {Sentence[]} 분석된 결과.
     */
    async tagSentence(...sentence) {
        let result = [];
        for (let paragraph of text) {
            let promiseResult;
            if(Array.isArray(paragraph)) {
                promiseResult = await this.tagSentence(...paragraph);
                result.push(...promiseResult);
            }else {
                promiseResult = await this._api.tagSentencePromise(paragraph);
                result.push(Sentence.fromJava(promiseResult));
            }
        }
        return result;
    }
}


/**
 * 문장 속성 부착기 Wrapper
 * @private
 */
class CanAnalyzeProperty extends Function {
    /**
     * Java API Object
     * @type {Object}
     * @private
     */
    _api = null;

    /**
     * 특성 부착형 분석기를 초기화합니다.
     *
     * @param {!API} api 사용할 분석기의 유형.
     * @param {!string} cls 사용할 클래스 유형.
     * @param {Object=} options
     * @param {string} options.apiKey ETRI 분석기의 경우, ETRI에서 발급받은 API Key
     */
    constructor(api, cls, options) {
        super();

        if (api === API.ETRI) {
            let apiKey = options.apiKey;
            this._api = API.query(api, cls)(apiKey);
        } else {
            this._api = API.query(api, cls)();
        }
    }

    /**
     * 문단(들)을 분석합니다.
     *
     * @param {...(string|Sentence|string[]|Sentence[])} text 분석할 문단(들).
     * 각 인자는 텍스트(str), 문장 객체(Sentence), 텍스트의 리스트, 문장 객체의 리스트 혼용 가능 (가변인자)
     * @returns {Sentence[]} 분석된 결과 (Flattened list)
     */
    async analyze(...text) {
        let result = [];
        for (let paragraph of text) {
            let promiseResult;
            if (Array.isArray(paragraph)) {
                promiseResult = await this.analyze(...paragraph);
                result.push(...promiseResult);
            } else if (paragraph instanceof Sentence) {
                promiseResult = await this._api.analyzePromise(paragraph.getReference());
                result.push(Sentence.fromJava(promiseResult));
            } else {
                promiseResult = await this._api.analyzePromise(paragraph);
                result.push(...JVM.toJsArray(promiseResult, Sentence.fromJava));
            }
        }

        return result;
    }
}

/**
 * 구문구조/의존구조 분석기 Wrapper
 *
 * ## 참고
 *
 * **구문구조 분석** 은 문장의 구성요소들(어절, 구, 절)이 이루는 문법적 구조를 분석하는 방법입니다.
 *
 * 예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는 2개의 절이 있습니다
 *
 * * 나는 밥을 먹었고
 * * 영희는 짐을 쌌다
 *
 * 각 절은 3개의 구를 포함합니다
 *
 * * 나는, 밥을, 영희는, 짐을: 체언구
 * * 먹었고, 쌌다: 용언구
 *
 * **의존구조 분석** 은 문장의 구성 어절들이 의존 또는 기능하는 관계를 분석하는 방법입니다.
 *
 * 예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는
 *
 * 가장 마지막 단어인 '쌌다'가 핵심 어구가 되며,
 *
 * * '먹었고'가 '쌌다'와 대등하게 연결되고
 * * '나는'은 '먹었고'의 주어로 기능하며
 * * '밥을'은 '먹었고'의 목적어로 기능합니다.
 * * '영희는'은 '쌌다'의 주어로 기능하고,
 * * '짐을'은 '쌌다'의 목적어로 기능합니다.
 *
 * 아래를 참고해보세요.
 *
 * * {@link module:koalanlp/data.Word#phrase|Word#phrase} 어절이 속한 직속 상위 구구조(Phrase)를 돌려주는 API.
 * * {@link module:koalanlp/data.Word#governorEdge|Word#governorEdge} 어절이 지배당하는 상위 의존구조 [DepEdge]를 가져오는 API
 * * {@link module:koalanlp/data.Word#dependentEdges|Word#dependentEdges} 어절이 직접 지배하는 하위 의존구조 [DepEdge]의 목록를 가져오는 API
 * * {@link module:koalanlp/data.Sentence#syntaxTree|Sentence#syntaxTree} 전체 문장을 분석한 [SyntaxTree]를 가져오는 API
 * * {@link module:koalanlp/data.Sentence#dependencies|Sentence#dependencies} 전체 문장을 분석한 의존구조 [DepEdge]의 목록을 가져오는 API
 * * {@link module:koalanlp/data.SyntaxTree|SyntaxTree} 구문구조를 저장하는 형태
 * * {@link module:koalanlp/data.DepEdge|DepEdge} 의존구문구조의 저장형태
 * * {@link module:koalanlp/types.PhraseTag|PhraseTag} 의존구조의 형태 분류를 갖는 Enum 값 (구구조 분류와 같음)
 * * {@link module:koalanlp/types.DependencyTag|DependencyTag} 의존구조의 기능 분류를 갖는 Enum 값
 *
 * @inheritDoc
 * @example
 * import { Parser } from 'koalanlp/proc';
 * import { HNN } from 'koalanlp/API';
 *
 * let parser = new Parser(HNN);
 * parser("문장을 분석해봅니다. 이렇게요.");
 */
export class Parser extends CanAnalyzeProperty {
    /**
     * 구문구조/의존구조분석기를 초기화합니다.
     *
     * @param {!API} api 사용할 분석기의 유형.
     * @param {Object=} options
     * @param {string} options.apiKey ETRI 분석기의 경우, ETRI에서 발급받은 API Key
     */
    constructor(api, options) {
        super(api, 'Parser', options);
        return assignProxy(this, 'analyze');
    }
}

/**
 * 개체명 인식기 Wrapper
 *
 * ## 참고
 *
 * **개체명 인식** 은 문장에서 인물, 장소, 기관, 대상 등을 인식하는 기술입니다.
 *
 * 예) '철저한 진상 조사를 촉구하는 국제사회의 목소리가 커지고 있는 가운데, 트럼프 미국 대통령은 되레 사우디를 감싸고 나섰습니다.'에서, 다음을 인식하는 기술입니다.
 *
 * * '트럼프': 인물
 * * '미국' : 국가
 * * '대통령' : 직위
 * * '사우디' : 국가
 *
 * 아래를 참고해보세요.
 *
 * * {@link module:koalanlp/data.Morpheme#entities|Morpheme#entities} 형태소를 포함하는 모든 [Entity]를 가져오는 API
 * * {@link module:koalanlp/data.Word#entities|Word#entities} 어절을 포함하는 모든 [Entity]를 가져오는 API
 * * {@link module:koalanlp/data.Sentence#entities|Sentence#entities} 문장에 포함된 모든 [Entity]를 가져오는 API
 * * {@link module:koalanlp/data.Entity|Entity} 개체명을 저장하는 형태
 * * {@link module:koalanlp/types.CoarseEntityType|CoarseEntityType} [Entity]의 대분류 개체명 분류구조 Enum 값
 *
 * @inheritDoc
 * @example
 * import { EntityRecognizer } from 'koalanlp/proc';
 * import { ETRI } from 'koalanlp/API';
 *
 * let parser = new EntityRecognizer(ETRI);
 * parser("문장을 분석해봅니다. 이렇게요.");
 */
export class EntityRecognizer extends CanAnalyzeProperty {
    /**
     * 개체명 인식기를 초기화합니다.
     *
     * @param {!API} api 사용할 분석기의 유형.
     * @param {Object=} options
     * @param {string} options.apiKey ETRI 분석기의 경우, ETRI에서 발급받은 API Key
     */
    constructor(api, options) {
        super(api, 'EntityRecognizer', options);
        return assignProxy(this, 'analyze');
    }
}

/**
 * 의미역 분석기 Wrapper
 *
 * ## 참고
 *
 * **의미역 결정** 은 문장의 구성 어절들의 역할/기능을 분석하는 방법입니다.
 *
 * 예) '나는 밥을 어제 집에서 먹었다'라는 문장에는
 *
 * 동사 '먹었다'를 중심으로
 *
 * * '나는'은 동작의 주체를,
 * * '밥을'은 동작의 대상을,
 * * '어제'는 동작의 시점을
 * * '집에서'는 동작의 장소를 나타냅니다.
 *
 * 아래를 참고해보세요.
 *
 * * {@link module:koalanlp/data.Word#predicateRoles|Word#predicateRoles} 어절이 논항인 [RoleEdge]의 술어를 가져오는 API
 * * {@link module:koalanlp/data.Word#argumentRoles|Word#argumentRoles} 어절이 술어인 [RoleEdge]의 논항들을 가져오는 API
 * * {@link module:koalanlp/data.Sentence#roles|Sentence#roles} 전체 문장을 분석한 의미역 구조 [RoleEdge]를 가져오는 API
 * * {@link module:koalanlp/data.RoleEdge|RoleEdge} 의미역 구조를 저장하는 형태
 * * {@link module:koalanlp/types.RoleType|RoleType} 의미역 분류를 갖는 Enum 값
 *
 * @inheritDoc
 * @example
 * import { RoleLabeler } from 'koalanlp/proc';
 * import { ETRI } from 'koalanlp/API';
 *
 * let parser = new RoleLabeler(ETRI);
 * parser("문장을 분석해봅니다. 이렇게요.");
 */
export class RoleLabeler extends CanAnalyzeProperty {
    /**
     * 의미역 분석기를 초기화합니다.
     *
     * @param {!API} api 사용할 분석기의 유형.
     * @param {Object=} options
     * @param {string} options.apiKey ETRI 분석기의 경우, ETRI에서 발급받은 API Key
     */
    constructor(api, options) {
        super(api, 'RoleLabeler', options);
        return assignProxy(this, 'analyze');
    }
}

/**
 * Java 사전 항목을 JS 사전 항목으로 변환.
 * @param entry Java 사전 항목
 * @return {DicEntry} JS 사전 항목
 * @private
 */
function readDicEntry(entry) {
    return {
        'surface': entry.getFirst(),
        'tag': POS.withName(entry.getSecond().name_)
    };
}

/**
 * 사전 Wrapper
 * @example
 * import { Dictionary } from 'koalanlp/proc';
 * import { KKMA } from 'koalanlp/API';
 *
 * let dict = Dictionary(KKMA);
 * dict.addUserDictionary({'surface': "하림"});
 */
export class Dictionary {
    /**
     * Java API Object
     * @type {Object}
     * @private
     */
    _api = null;

    /**
     * 사용자 정의 사전을 연결합니다.
     *
     * @param {!API} api 사용자 정의 사전을 연결할 API 패키지.
     */
    constructor(api) {
        self._api = API.query(api, 'Dictionary').INSTANCE;
    }

    /**
     * 사용자 사전에, 표면형과 그 품사를 추가.
     * @param {...DicEntry} pairs 추가할 형태소와 품사들. (가변인자)
     */
    async addUserDictionary(...pairs) {
        let surfaceList = [];
        let tagList = [];

        for (let pair of pairs) {
            surfaceList.push(pair.surface);

            let tag = pair.tag ? pair.tag.reference : POS.NNP.reference;
            tagList.push(tag);
        }

        await this._api.addUserDictionaryPromise(JVM.listOf(surfaceList), JVM.listOf(tagList));
    }

    /**
     * 사전에 등재되어 있는지 확인합니다.
     * @param {string} word 확인할 형태소
     * @param {POS} posTags 세종품사들(기본값: NNP 고유명사, NNG 일반명사)
     * @returns {boolean} 사전에 포함된다면 True 아니면 False.
     */
    async contains(word, ...posTags) {
        let tags = (posTags.length > 0) ? posTags : [POS.NNP, POS.NNG];
        if (tags.length === 1) {
            let tag = tags[0];
            return await this._api.containsPromise(JVM.pair(word, tag.reference));
        } else {
            let tagsRef = tags.map((tag) => tag.reference);
            return await this._api.containsPromise(word, JVM.setOf(tagsRef));
        }
    }

    /**
     * 다른 사전을 참조하여, 선택된 사전에 없는 단어를 사용자사전으로 추가합니다.
     *
     * @param {Dictionary} other 참조할 사전
     * @param {boolean} [fastAppend=false] 선택된 사전에 존재하는지를 검사하지 않고 빠르게 추가하고자 할 때.
     * @param {POSFilter} [filter=(x) => x.isNoun()] 가져올 품사나, 품사의 리스트, 또는 해당 품사인지 판단하는 함수.
     */
    async importFrom(other, fastAppend = false, filter = (x) => x.isNoun()) {
        let tags = [];
        if (filter instanceof Function) {
            for (let tag of POS.values()) {
                if (filter(tag)) tags.append(tag.name);
            }
        } else {
            for (let tag of filter) {
                tags.append(tag.name);
            }
        }

        await this._api.importFromPromise(other._api, fastAppend, JVM.posFilter(tags));
    }

    /**
     * 원본 사전에 등재된 항목 중에서, 지정된 형태소의 항목만을 가져옵니다. (복합 품사 결합 형태는 제외)
     *
     * @param {POSFilter} [filter=(x) => x.isNoun()] 가져올 품사나, 품사의 리스트, 또는 해당 품사인지 판단하는 함수.
     * @return {IterableIterator.&lt;DicEntry>} {'surface':형태소, 'tag':품사}의 generator
     */
    async getBaseEntries(filter = (x) => x.isNoun()) {
        let tags = [];
        if (filter instanceof Function) {
            for (let tag of POS.values()) {
                if (filter(tag)) tags.append(tag.name);
            }
        } else {
            for (let tag of filter) {
                tags.append(tag.name);
            }
        }

        let entries = await this._api.getBaseEntriesPromise(JVM.posFilter(tags));
        return function* () {
            while (entries.hasNext()) {
                yield readDicEntry(entries.next());
            }
        };
    }

    /**
     * 사용자 사전에 등재된 모든 항목을 가져옵니다.
     * @return {DicEntry[]} {'surface':형태소, 'tag':품사}의 list
     */
    async getItems() {
        return JVM.toJsArray(await this._api.getItemsPromise(), readDicEntry);
    }

    /**
     * 사전에 등재되어 있는지 확인하고, 사전에 없는단어만 반환합니다.
     * @param {boolean} onlySystemDic 시스템 사전에서만 검색할지 결정합니다.
     * @param {DicEntry} word {'surface':형태소, 'tag':품사}들. (가변인자)
     * @return {DicEntry[]} 사전에 없는 단어들
     */
    async getNotExists(onlySystemDic, ...word) {
        let zipped = word.map((pair) => JVM.pair(pair.surface, pair.tag.reference))
        return JVM.toJsArray(await this._api.getNotExistsPromise(onlySystemDic, ...zipped), readDicEntry);
    }
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Dec 03 2018 01:43:17 GMT+0900 (GMT+09:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>


<script src="scripts/collapse.js"></script>



</body>
</html>
